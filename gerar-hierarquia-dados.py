data = [
  "Nível|Titulo",
  "0|Sossego",
  "1|Horas Calendário",
  "1|Britagem",
  "2|Britagem Primária",
  "3|Horas Manutenção Preventiva (h)",
  "3|Horas Manutenção Corretiva (h)",
  "3|Horas de parada para manutenção Britagem",
  "3|Horas disponíveis Britagem",
  "3|Disponibilidade física (%)",
  "3|Horas de paradas devido à operação e ao processo",
  "3|UF Britagem (%)",
  "3|Horas trabalhadas",
  "3|Rendimento operacional (%)",
  "3|ROM (tbn)",
  "3|Taxa da Britagem (t/h)",
  "1|Usina",
  "2|Usina",
  "3|Horas Manutenção Preventiva (h)",
  "3|Horas Manutenção Corretiva (h)",
  "3|Horas de parada para manutenção",
  "3|Horas Disponíveis",
  "3|Disponibilidade Física (%)",
  "3|Tempo de parada operacional (h)",
  "3|Utilização (%)",
  "3|Horas trabalhadas",
  "3|Rendimento operacional (%)",
  "3|ROP (tbn)",
  "3|ROP (tbs)",
  "3|Taxa SAG (t/h)",
  "3|Massa Alimentada Flotação (tbs)",
  "3|Teor de Cobre alimentação da Flotação (%)",
  "3|Teor de Au alimentação da Flotação (g/t)",
  "3|Cobre contido na alimentação (ton)",
  "3|Recuperação em massa flotacao (%)",
  "3|Produção de concentrado (tbs)",
  "3|Produção de concentrado (tbu)",
  "3|Teor de Cobre no concentrado (%)",
  "3|Cobre contido no concentrado (ton)",
  "3|Cobre contido acumulado (t)",
  "3|Cobre contido acumulado orç vs proj (t)",
  "3|Cobre contido trimestral (t)",
  "3|Cobre contido (ton) - Orçado",
  "3|Cobre contido acumulado (t) - Orçado",
  "3|Cobre contido trimestral (t) - Orçado",
  "3|Recuperação de Cu  Flotação(%)",
  "3|Umidade (%)",
  "3|Au no Concentrado (g/t)",
  "3|Au contido no Concentrado (kg)",
  "3|Au contido acumulado (kg)",
  "3|Au contido acum. Orç. vs Proj. (kg)",
  "3|Au contido trimestral produzido (kg)",
  "3|Au contido (kg) - Orçado",
  "3|Au contido acumulado (kg) - Orçado",
  "3|Au contido trimestral orçado (kg)",
  "3|Recuperação de ouro(%)",
  "0|Salobo",
  "1|Horas Calendário",
  "1|Britagem",
  "2|Britagem Primária",
  "3|Horas Manutenção Preventiva (h)",
  "3|Horas Manutenção Corretiva (h)",
  "3|Horas de parada para manutenção Britagem",
  "3|Horas disponíveis Britagem",
  "3|Disponibilidade física (%)",
  "3|Horas de paradas devido à operação e ao processo",
  "3|UF Britagem (%)",
  "3|Horas trabalhadas",
  "3|Rendimento operacional (%)",
  "3|ROM (tbn)",
  "3|Taxa da Britagem (t/h)",
  "2|Britagem Secundária",
  "3|Horas Manutenção Preventiva (h)",
  "3|Horas Manutenção Corretiva (h)",
  "3|Horas de parada para manutenção Britagem",
  "3|Horas disponíveis Britagem",
  "3|Disponibilidade física (%)",
  "3|Horas de paradas devido à operação e ao processo",
  "3|UF Britagem (%)",
  "3|Horas trabalhadas",
  "3|Rendimento operacional (%)",
  "3|ROM (tbn)",
  "3|Taxa da Britagem (t/h)",
  "1|Usina",
  "2|Usina",
  "3|Horas Manutenção Preventiva (h)",
  "3|Horas Manutenção Corretiva (h)",
  "3|Horas de parada para manutenção",
  "3|Horas Disponíveis",
  "3|Disponibilidade Física (%)",
  "3|Tempo de parada operacional (h)",
  "3|Utilização (%)",
  "3|Horas trabalhadas",
  "3|Rendimento operacional (%)",
  "3|ROP (tbn)",
  "3|ROP (tbs)",
  "3|Taxa SAG (t/h)",
  "3|Massa Alimentada Flotação (tbs)",
  "3|Teor de Cobre alimentação da Flotação (%)",
  "3|Teor de Au alimentação da Flotação (g/t)",
  "3|Cobre contido na alimentação (ton)",
  "3|Recuperação em massa flotacao (%)",
  "3|Produção de concentrado (tbs)",
  "3|Produção de concentrado (tbu)",
  "3|Teor de Cobre no concentrado (%)",
  "3|Cobre contido no concentrado (ton)",
  "3|Cobre contido acumulado (t)",
  "3|Cobre contido acumulado orç vs proj (t)",
  "3|Cobre contido trimestral (t)",
  "3|Cobre contido (ton) - Orçado",
  "3|Cobre contido acumulado (t) - Orçado",
  "3|Cobre contido trimestral (t) - Orçado",
  "3|Recuperação de Cu  Flotação(%)",
  "3|Umidade (%)",
  "3|Au no Concentrado (g/t)",
  "3|Au contido no Concentrado (kg)",
  "3|Au contido acumulado (kg)",
  "3|Au contido acum. Orç. vs Proj. (kg)",
  "3|Au contido trimestral produzido (kg)",
  "3|Au contido (kg) - Orçado",
  "3|Au contido acumulado (kg) - Orçado",
  "3|Au contido trimestral orçado (kg)",
  "3|Recuperação de ouro(%)",
  "0|Onça Puma",
  "1|Horas Calendário",
  "1|Britagem",
  "2|Britagem Primária",
  "3|Horas Manutenção Preventiva (h)",
  "3|Horas Manutenção Corretiva (h)",
  "3|Horas de parada para manutenção Britagem",
  "3|Horas disponíveis Britagem",
  "3|Disponibilidade física (%)",
  "3|Horas de paradas devido à operação e ao processo",
  "3|UF Britagem (%)",
  "3|Horas trabalhadas",
  "3|Rendimento operacional (%)",
  "3|ROM (tbn)",
  "3|Taxa da Britagem (t/h)",
  "1|Usina",
  "2|Usina",
  "3|Horas Manutenção Preventiva (h)",
  "3|Horas Manutenção Corretiva (h)",
  "3|Horas de parada para manutenção",
  "3|Horas Disponíveis",
  "3|Disponibilidade Física (%)",
  "3|Tempo de parada operacional (h)",
  "3|Utilização (%)",
  "3|Horas trabalhadas",
  "3|Rendimento operacional (%)",
]

replacements = [
  {
    "value": "__",
    "replace": "_"
  },
  {
    "value": "_horas_manutencao_preventiva_h",
    "replace": "_HMP"
  },
  {
    "value": "_horas_manutencao_corretiva_h",
    "replace": "_HMC"
  },
  {
    "value": "_horas_de_parada_para_manutencao",
    "replace": "_HPM"
  },
  {
    "value": "_horas_disponiveis",
    "replace": "_HD"
  },
  {
    "value": "_disponibilidade_fisica",
    "replace": "_DF"
  },
  {
    "value": "_tempo_de_parada_operacional_h",
    "replace": "_TPO"
  },
  {
    "value": "_horas_trabalhadas",
    "replace": "_HT"
  },
  {
    "value": "_rendimento_operacional_",
    "replace": "_RO"
  },
  {
    "value": "horas_de_paradas_devido_a_operacao_e_ao_processo",
    "replace": "hora_parada_operacao_processo"
  },
  {
    "value": "_hora_parada_operacao_processo",
    "replace": "_HPOP"
  }
]

import json
import re
from unidecode import unidecode
import uuid

def generate_guid():
    return str(uuid.uuid4())

def to_snake_case(text):
    # Remove acentos do texto.
    text = unidecode(text)

    # Remove espaços em branco do início e do fim do texto.
    text = text.strip()

    # Remove caracteres especiais no final do texto, como ponto, exclamação, etc.
    if text[-1] in ['_', '-', '.', '!', '?', ':', ';']:
        text = text[:-1]

    # Converte o texto para letras minúsculas e substitui espaços por underscores.
    text = '_'.join(text.lower().split())

    # Remove qualquer caractere que não seja uma letra ou underscore.
    text = re.sub(r'[^a-z_]', '', text)

    # Retorna o texto no formato snake_case.
    return text

# Define uma função chamada "replace_string" que substitui strings com base em um dicionário "replacements".
def replace_string(input_string):
    for item in replacements:
        input_string = input_string.replace(item['value'], item['replace'])
    return input_string

# Cria um dicionário JSON inicial chamado "hierarchy_data" com alguns campos.
hierarchy_data = {"title": "Root", "category": None, "children": [], "anchor": None}

# Inicializa uma lista chamada "current_level" com o dicionário "hierarchy_data".
current_level = [hierarchy_data]

# Inicializa a variável "current_depth" com -1 para rastrear o nível atual.
current_depth = -1

# Define um prefixo para âncoras.
anchor_prefix = "#Planta_Onca_Puma_"

# Itera sobre os itens da lista "data" (que deve ser definida em algum lugar).
for item in data[1:]:
    # Divide o item em "level" e "title".
    level, title = item.split("|")
    level = int(level)

    # Fecha níveis anteriores que não são mais necessários.
    while current_depth >= level:
        current_level.pop()
        current_depth -= 1

    # Converte o título em snake_case (nome da categoria).
    category = to_snake_case(title)

    # Se o nível for 3, cria uma âncora com base na hierarquia.
    if level == 3:
        category = replace_string(category)
        anchor = anchor_prefix + "_".join([node["category"] for node in current_level[1:]]) + "_" + category
        anchor = replace_string(anchor)
        new_node = {"title": title, "category": category, "anchor": anchor}
    else:
        new_node = {"title": title, "category": category, "children": []}

    # Adiciona o novo nó como filho do nó atual no nível apropriado.
    current_level[level]["children"].append(new_node)

    # Atualiza o nível e a profundidade atual.
    current_level.append(new_node)
    current_depth = level


output_filename = generate_guid() + ".json"


with open(output_filename, 'w', encoding='utf-8') as json_file:
    # Escreve o conteúdo JSON no arquivo com formatação.
    json.dump(hierarchy_data["children"], json_file, ensure_ascii=False, indent=2)


print(f"O JSON foi salvo em {output_filename}")

